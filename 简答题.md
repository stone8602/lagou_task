1.Mybatis动态sql是做什么的？都有哪些动态sql？简述一下动态sql的执行原理？
答：动态sql是用来根据不同的查询条件生成不同的SQL语句，或者将一些使用频率高的SQL语句抽离出来共用。
动态sql有if、choose(when、otherwise)、trim、where、set、foreach。
动态sql的执行原理，首先，mybatis会读取配置文件，将sql信息读取到内存当中；执行语句时，会根据传递的参数来处理sql语句，填充参数，得到最终需要执行的sql，然后执行。

2.Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？
答：Mybatis支持延迟加载。只有配置了association关联对象或collection关联集合对象才有延迟加载的功能。
它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，如果调用某个关联对象时，发现是Null，就会使用动态代理生成延迟加载代理对象，执行配置的关联查询sql去查询出对应的关联对象并赋值。

3.Mybatis都有哪些Executor执行器？它们之间的区别是什么？
答：Mybatis有三种基本的Executor执行器:SimpleExecutor、ReuseExecutor、BatchExecutor。
SimpleExecutor 每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
ReuseExecutor 执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。
BatchExecutor 执行update时，将所有sql都添加到批处理中，等待统一执行，它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。

4.简述下Mybatis的一级、二级缓存（分别从存储结构、范围、失效场景三个方面来作答）？
答：Mybatis的缓存机制，是指在查询的时候，会根据key去缓存中查询是否有缓存内容，如果有，直接返回，如果没有，才会去执行SQL。
一级缓存默认开启，使用的数据结构为HashMap，key是hashcode+statementId+sql语句生成的，Value为查询出来的结果集映射成的java对象。一级缓存的作用域是SqlSession，在执行insert、update、delete等操作commit后会清空该SQLSession缓存。
二级缓存需要手动开启，使用的数据结构也是HashMap，key的生成方式与一级缓存相同，但是value不再是java对象，因为二级缓存不一定是放在内存里的，所以存储的是java对象的值，对象必须实现Serializable接口。二级缓存的作用域是mapper。在执行insert、update、delete等操作commit后会清空该mapper缓存。

5.简述Mybatis的插件运行原理，以及如何编写一个插件？
答：mybatis的插件是使用拦截器去拦截Executor、StatementHandler、ParameterHandler、ResultSetHandler这四个接口，增强其功能，增强功能本质上是借助于底层的动态代理实现的。
自定义插件，首先自定义一个Intercepror接口的实现类，重写intercept()方法、plugin()方法、setProperties()方法实现自定义增强效果；然后设置插件的签名，使用@Intercepts标签和@Signature标签告诉mybatis拦截哪个对象的哪个方法；最后将插件注册到全局配置文件中。